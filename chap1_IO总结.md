# IO总结 #  
***
## Linux网络I/O模型简介 ##
**Java所有的IO模型都是基于Linux内核提供的I/O模型。**Linux内核将所有的外部设备都看作是一个文件，对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor(fd,文件描述符)。而对一个socket的读写也会有相应的描述符，称为socketfd。描述符就是一个数字，指向内核中的一个结构体（文件路径，数据区等一些属性）。  
  
*Unix提供5中I/O模型*  

* **阻塞I/O模型**  
进程空间中调用recvfrom，系统调用过程，内核操作分为**两部分**：等待数据、将数据从内核拷贝到用户空间。进行从调用recvfrom开始到它返回的整段时间都是被阻塞的，因此被称为阻塞I/O模型。  
  
* **非阻塞I/O模型**  
recvfrom从应用层到内核的时候，如果*该缓冲区没有数据的话*，就直接返回一个*EWOULDBLOCK*错误，一般都对非阻塞的I/O模型进行轮询检查这个状态

* **I/O复用模型**  
Linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。由于select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限。Linux还提供了一个epoll系统调用，使用基于事件驱动方式替代顺序扫描，当有fd准备就绪时，立即回调函数rollback。

* **信号驱动I/O模型**  
首先开启套接字信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过*信号回调*通知应用程序调用recvfrom来读取数据

* **异步I/O**  
告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型和信号驱动的主要区别是：*信号驱动I/O由内核通知我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成*。  

----------

## I/O多路复用技术  ##
多个客户端接入时，传统多线程/多进程模型，I/O多路复用通过把多个I/O阻塞复用到同一个select的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。支持I/O多路复用的系统调用有select、pselect、poll、epoll。epoll解决select的缺陷：  
  
* **支持一个进程打开的socket描述符不受限制（仅受限于操作系统最大文件句柄数）**  
  
* **I/O效率不会随着FD数目的增加而线性下降**  
epoll只会对活跃的socket进行操作，由于在内核实现中epoll是根据每个fd上面的callback函数实现的，只有活跃的socket才会去调用callback函数，其余idle状态的socket则不会。epoll在这一点上实现了一个**伪AIO**
 
* **使用mmap加速内核域用户空间的消息传递**  
epoll通过内核和用户空间mmap同一块内存实现

----------

## Java的I/O演化 ##
* JDK1.0到JDK1.3，Java的I/O类库都是原始的；  
* JDK1.4，增加了java.nio包，提供了异步I/O开发的API和类库 
* JDK1.7，NIO进行升级NIO2.0